---
title: 数据结构与算法-排序-查找-哈希表
categories: 
    - [计算机学科,java,数据结构与算法]
tags:
    - java
    - 数据结构与算法
    - 计算机学科
    - 排序
    - 查找
    - 哈希表
---

### 冒泡排序

基本介绍

冒泡排序（Bubble Sorting）的基本思想是：通过对待

排序序列从前向后（从下标较小的元素开始）,依次比较

相邻元素的值，若发现逆序则交换，使值较大

的元素逐渐从前移向后部，就象水底下的气泡一样逐渐

向上冒。

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下

来没有进行过交换，就说明序列有序，因此要在排序过程中设置

一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900791.png)

演示冒泡过程的例子(图解)

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900022.png)

冒泡排序应用实例

我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3, 9, -1, 10, -2  使用冒泡排序法将其排成一个从小到大的有序数列。

图解：

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161900920.png)

代码实现：

先将排序的结构拆分了写，步骤如下：

每次进行排序的时候都需要将长度 - 1 - n 因为排序后范围总是要缩小的否则就会一直来回的排序。

```java
public class BubbleSort01 {
    public static void main(String[] args) {
        int[] arr = {-1,-2,3,1,20,10,9,5};
        int temp = 0;
        for(int i = 0;i < arr.length - 1;i ++){
            if(arr[i] > arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
        System.out.println("第一趟排序结果："+ Arrays.toString(arr));
        for(int i = 0;i < arr.length - 1 - 1;i ++){
            if(arr[i] > arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
        System.out.println("第二趟排序结果："+Arrays.toString(arr));
        for(int i = 0;i < arr.length - 1 - 2;i ++){
            if(arr[i] > arr[i+1]){
                temp = arr[i];
                arr[i] = arr[i+1];
                arr[i+1] = temp;
            }
        }
        System.out.println("第三趟排序结果："+Arrays.toString(arr));
    }
}
```

简化代码：将排序的过程结合为嵌套循环来完成冒泡排序：

代码如下：

```java
@SuppressWarnings("all")
public class BubbleSort {
    public static void main(String[] args) {
        int temp = 0;
        int[] arr = {-1,-2,3,1,10,9,5};
        //标识变量
        boolean flag = false;
        //冒泡排序 的时间复杂度为 O(n^2)
        for(int i = 0;i < arr.length - 1;i ++){
            for(int j = 0;j < arr.length - i - 1;j ++){
                if(arr[j] > arr[j+1]){
                    //如果进行过交换则将标识变量赋值为true
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
            System.out.println("第"+i+"趟，的排序结果为: "+Arrays.toString(arr));
            //判断标识变量进行对应的操作
            if(!flag){
                //在一趟排序中，一次交换都没有发生过
                break;
            }else{
                //如果发生过交换则进入else中，将flag重置进行下次判断
                flag = false;
            }
        }
    }
}
```

### 选择排序

**基本介绍** 

选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

**选择排序思想**: 

选择排序（select sorting）也是一种简单的排序方法。它的**基本思想**是：第一次从arr[0]`~`arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]`~`arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]`~`arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

**选择排序思路分析图***: 

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901514.png)
101, 34, 119, 1

代码实现：

```java
public static void selectionSort(int[] arr) {
   /*判断数组为空或为一个元素的情况，即边界检查*/
   if (arr == null || arr.length < 2) {
      return;
   }

   /*每次要进行比较的两个数，的前面那个数的下标*/
   for (int i = 0; i < arr.length - 1; i++) { 
      //min变量保存该趟比较过程中，最小元素所对应的索引，
      //先假设前面的元素为最小元素
      int minIndex = i;
      /*每趟比较，将前面的元素与其后的元素逐个比较*/
      for (int j = i + 1; j < arr.length; j++) {
         //如果后面的元素小，将后面元素的索引极为最小值的索引
         if(arr[j] < arr[minIndex]) {
            minIndex = j;
         }
      }
      //然后交换此次查找到的最小值和原始的最小值
      swap(arr, i, minIndex);
   }
}

public static void swap(int[] arr, int i, int j) {
   int tmp = arr[i];
   arr[i] = arr[j];
   arr[j] = tmp;
}
```

-  选择排序的优化

```java
public class Demo {
    public static void main(String[] args) {
        int[] arr = {-1,-2,3,1,20,10,9,5};
        sort(arr);
    }
    public static void sort(int[] arr){
        int left = 0;
        int right = arr.length - 1;
        while(left < right){
            int max = right;
            int min = left;
            for(int i = left;i <= right;i ++){
                if(arr[max] < arr[i])
                    max = i;
                if(arr[min] > arr[i])
                    min = i;
            }
            //最大值放在最右端
            int temp = arr[max];
            arr[max] = arr[right];
            arr[right] = temp;

            if(min == right){
                min = max;
            }
            //最下值放在最左端
            temp = arr[min];
            arr[min] = arr[left];
            arr[left] = temp;
            left ++;
            right --;
        }
        System.out.println(Arrays.toString(arr));
    }
}
```

### 插入排序

**插入排序法介绍**：

插入式排序属于内部排序法，是对于预排序的元素以插入的方式找寻元素的适当位置，以达到排序的目的。

**插入排序法思想**:

插入排序（Insertion Sorting）的**基本思想**是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

**插入排序思路图**：

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901111.png)

代码实现：

```java
public static void main(String[]args){
    int[] ar = {5,3,4,6,2,1};
    //需要使用j循环值来进行位置互换
    int j;
    for(int i = 1;i < ar.length;i ++){
        //取一个值进行比较
        int tmp = ar[i];
        //j = i - 1 循环0等于或到j的数值,j也就是i-1的值,判断是否满足交换条件执行则j-- 
        for(j = i-1;j >= 0 && ar[j] > tmp;j --){
            //将大的元素赋值到索引前
            ar[j+1] = ar[j];
        }
        //将元素小的赋值到索引后,因为 j-- j循环变量在满足条件执行方法体时不会及时执行 j--
        ar[j+1] = tmp;
    }
    System.out.println(Arrays.toString(ar));
}
```

-  优化 - 折半插入排序

```java
public static void main(String[]args){
    int[] arr = {5,3,4,6,2,1};
    int n = arr.length;
    int j,low,mid,high,temp;
    for(int i = 1;i < n;i ++){
        //循环的起始数据
        low = 0;
        //循环的循环数值
        high = i - 1;
        //取第i个元素赋值到tmp中进行比较
        temp = arr[i];
        /*找到合适的插入位置high+1，如果中间位置元素
         *比要插入元素大，则查找区域向低半区移动，否
         *则向高半区移动
         */
        //从前面的元素开始判断到temp的元素如果不满足则直接进行下一次循环
        while(low <= high){
        /*每次执行将low与长度相加的值除2得出mid指针位置*/
            mid = (low+high)/2;
            //判断mid的索引位置的值 是否 大于temp的值
            if(arr[mid] > temp){
                //满足交换条件,指针位置-1,缩短判断范围
                high = mid - 1;
            }else{
                //不满足交换条件 指针位置+1,缩短判断范围
                low = mid + 1;
            }
        }
        /*high+1后的元素后移*/
        //经过上面判断i-1为temp后一位的位置,从high循环到 i
        for(j = i - 1;j >= high + 1;j --) {
            arr[j + 1] = arr[j];
        }
        /*将元素插入到指定位置*/
        arr[j + 1] = temp;
    }
    System.out.println(Arrays.toString(arr));
}
```

-  优化 - 路插入排序

```java
int j, first, last, mid;
int len = arr.length;
/*临时数组*/
int[] tempArr =new int[len];
tempArr[0] = arr[0];
/*first和last分别指临时数组tempArr中排好序的元素的第一个和最后一个位置*/
first = last = 0;

for(int i = 1; i<len; i++){
   /*j 是调整系数*/
   if(first > last){
      j = len;        
   }else{
      j = 0;
   }
   /*tempArr中间元素的位置*/
   mid = ((first+last+j)/2)%len; 
   /*arr[i]应该插入在tempArr的前半部分*/
   if(arr[i] < tempArr[mid]){      
      /*j指向tempArr数组中的第一个元素*/
      j = first;
      /*first 前移，取余是为了实现循环数组效果*/
      first = (first-1+len)%len;  
      /*待插元素大于 j 所指元素*/
      while(arr[i] > tempArr[j]){    
         /*j 所指元素前移，取余是为了实现循环数组效果*/
         tempArr[(j-1+len)%len] = tempArr[j];  
         /*j 指向下一个元素*/
         j = j+1;
      }
      /*移动结束，待插元素插在tempArr[j]前*/
      tempArr[(j-1+len)%len] = arr[i];    
      /*arr[i]应该插入在tempArr的后半部分*/
   }else{
      /*j指向tempArr数组中的最后一个元素*/
      j = last;
      /*last后移， 指向插入后的最后一个元素*/
      last++;
      /*待插元素小于 j 所指元素*/
      while(arr[i] < tempArr[j]){  
         /*j 所指元素后移*/
         tempArr[(j+1)%len] = tempArr[j]; 
         /*j 指向上一个元素*/
         j = (j-1+len)%len;         
      }
      /*移动结束，待插元素插在tempArr[j]后*/
      tempArr[(j+1)%len] = arr[i]; 
   }
}

/*把在tempArr中排好序的元素依次赋给arr*/
for(int i = 0; i < len; i++){                    
   arr[i] = tempArr[(first+i)%len];
}
```

### 希尔排序

**简单插入排序存在的问题** 

我们看简单的插入排序可能存在的问题.

数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：

{2,3,4,5,6,6}

{2,3,4,5,5,6}

{2,3,4,4,5,6}

{2,3,3,4,5,6}

{2,2,3,4,5,6}

{1,2,3,4,5,6}

**结论**:当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.

希尔排序法介绍

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

希尔排序法基本思想

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

希尔排序法  的示意图

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901589.png)

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161901412.png)

代码实现：

==交换法==（效率较低）

```java
public static void main(String[]args){
    int[] ar = {8,9,1,7,2,3,5,4,6,0};
    art(ar);
}
public static void art(int[] arr){
    int len = arr.length;
    //每次执行外循环将数组的 长度/2 分开
    for (int gap = len/2;gap > 0;gap = gap/2) {
        //从/2的长度开始循环数组全部从/2后的长度开始循环到数组长度
        for (int i = gap;i < len;i++) {
            //将从/2的长度开始进行遍历
            int j = i;
            //判断循环 判断j是否大于等于0 和 数组前后元素的大小
            while (j - gap >= 0 && arr[j] < arr[j - gap]) {
                //调用排序方法
                sort(arr,j,j - gap);
                //当j-gap还是满足if判断条件那么就看第二个条件是否满足如果满足则再次进行交换位置
                j = j - gap;
            }
        }
    }
}
public static void sort(int[] ar,int a,int b){
    int tmp = ar[b];
    ar[b] = ar[a];
    ar[a] = tmp;
    System.out.println(Arrays.toString(ar));
}
```

==移动法==（效率比交换高很多很多）

```java
//希尔排序
public static void shellSort(int[] arr){
   int len = arr.length;
   for(int gap = len / 2;gap > 0;gap = gap / 2){
      for(int  i = gap;i < len;i ++){
         //使用插入排序的思路
         int j = i;
         int temp = arr[j];
         while(j - gap >= 0 && temp < arr[j - gap]){
            arr[j] = arr[j - gap];
            j -= gap;
         }
         arr[j] = temp;
      }
   }
}
```

### 快速排序

**快速排序法介绍**:

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列

**快速排序法示意图**:

以每个递归分支的最后一个元素为基准进行排序

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902712.png)

以每个递归分支的最中间的元素为基准进行排序

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902376.png)

代码实现:

```java
@SuppressWarnings("all")
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {-1,-2,3,1,20,10,9,5};
        quickSort(arr,0,arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    public static void quickSort(int[] arr,int left,int right){
        int low = left;//左下标
        int max = right;//右下标
        //中间下标
        int pivot = arr[(left + right) / 2];

        //临时交换值变量
        int temp = 0;
        //while循环的目的是让比pivot值小放到左边比pivot值大的放到右边
        while(low < max){
            //在pivot的左边一直找，找到大于pivot值，才退出
            while(arr[low] < pivot){
                low += 1;
            }

            //在pivot的右边一直找，找到小于pivot值，才退出
            while(arr[max] > pivot){
                max -= 1;
            }

            //如果low >= max说明pivot 的左右两边的值，已经按照左边全部是
            //小于等于pivot的值，右边全部是大于等于pivot的值
            if(low >= max){
                break;
            }

            //交换
            temp = arr[low];
            arr[low] = arr[max];
            arr[max] = temp;

            //如果交换完后，发现这个arr[low] == pivot值 相等 则 max -- ，前移
            if(arr[low] == pivot){
                max -= 1;
            }

            //如果交换完后，发现这个arr[max] == pivot值 相等 则 low ++ ，后移
            if(arr[max] == pivot){
                low += 1;
            }

            //如果low == max,必须low ++ , max -- ,否则会出现堆栈溢出
            if(low == max){
                low += 1;
                max -= 1;
            }

            //向左递归
            if(left < max){
                quickSort(arr,left,max);
            }

            //向右递归
            if(right > low){
                quickSort(arr,low,right);
            }
        }
    }
}
```

### 归并排序

**归并排序介绍**:

归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

**归并排序思想示意图1-基本思想**:

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902386.png)

**说明**:

可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。

**归并排序思想示意图2-合并相邻有序子序列**:

再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902315.png)

代码实现：

```java
@SuppressWarnings("all")
public class GuibingSort {
    public static void main(String[] args) {
        int[] arr= {8,4,5,7,1,3,6,2,0};
        //归并排序需要一个额外空间
        int[] temp = new int[arr.length];
        mergeSort(arr,0,arr.length - 1,temp);
        System.out.println(Arrays.toString(arr));
    }

    /**
     * 分+合方法
     * @param arr
     * @param left
     * @param right
     * @param temp
     */
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if(left < right){
            //中间索引
            int mid = (left + right) / 2;
            //向左递归进行分解
            mergeSort(arr,left,mid,temp);
            //向右递归进行分解
            mergeSort(arr,mid + 1,right,temp);
            //合并
            merge(arr,left,mid,right,temp);
        }
    }

    /**
     * 合并方法
     * @param arr 排序的原始数据
     * @param left 左边有序序列的初始索引
     * @param mid 中间索引
     * @param right 右边索引
     * @param temp 做中转的数组
     */
    public static void merge(int[] arr, int left, int mid, int right, int[] temp) {
        int i = left;//初始化i，左边有序序列的初始索引
        int j = mid + 1;//初始化j，右边有序序列的初始索引
        int t = 0;//指向temp数组的当前索引

        /**
         * (一)
         * 先把左右两边(有序)的数据按照规则填充到temp数组
         * 直到左右两边的有序序列，有一边处理完毕为止
         */
        while (i <= mid && j <= right) {
            /**
             * 如果左边有序序列的当前元素，小于等于右边有序的当前元素
             * 即将左边的当前元素，拷贝到temp数组
             * 然后t ++ i ++
             */
            if (arr[i] <= arr[j]) {
                temp[t] = arr[i];
                t += 1;
                i += 1;
            }else{
                temp[t] = arr[j];
                j += 1;
                t += 1;
            }
        }

        /**
         * (二)
         * 把有剩余数据的一边的数据依次全部填充到temp
         */
        //左边的有序序列还有剩余的元素，就全部填充到temp
        while(i <= mid){
            temp[t] = arr[i];
            t += 1;
            i += 1;
        }
        //右边的有序序列还有剩余的元素，就全部填充到temp
        while(j <= right){
            temp[t] = arr[j];
            t += 1;
            j += 1;
        }

        /**
         * (三)
         * 将temp数组的元素拷贝到arr
         * 注意：并不是每次都拷贝所有的数据
         */
        t = 0;
        int tempLeft = left;
        /**
         * 第一次合并tempLeft = 0, right = 1
         * 第二次合并tempLeft = 2 right = 3
         * 第三次合并tempLeft = 0 right = 3
         * 最后一次tempLeft = 0 right = 7
         */
        while(tempLeft <= right){
            arr[tempLeft] = temp[t];
            t += 1;
            tempLeft += 1;
        }
    }
}
```

### 基数排序

**基数排序(桶排序)介绍**:

1. [基](https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498)[数排序](https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498)（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的[元素分配](https://baike.baidu.com/item/%E5%85%83%E7%B4%A0%E5%88%86%E9%85%8D/2107419)至某些“桶”中，达到排序的作用

2. 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法

3. 基数排序(Radix Sort)是[桶排序](http://www.cnblogs.com/skywang12345/p/3602737.html)的扩展

4. 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

**基数排序基本思想** 

1. 将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

2. 这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤

**基数排序图文说明** 

将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。

第1轮排序 [按照个位排序]:

说明： 事先准备10个数组(10个桶)， 0-9 分别对应 位数的 0-9

1. 将 各个数，按照个位大小 放入到 对应的 各个数组中
2. 然后从 0-9 个数组/桶，依次，按照加入元素的先后顺序取出

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902994.png)

示意图：

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902405.png)

分解代码：

```java
@SuppressWarnings("all")
public class JichuSort {
    public static void main(String[] args) {
        int[] arr = {53,3,542,748,14,214};
        radixSort(arr);
    }

    //基数排序方法
    public static void radixSort(int[] arr){

        /**
         * 第一轮（针对每个元素的个位进行排序处理）
         * 定义一个二维数组，表示10个桶，每个桶就是一个一维数组
         * 说明：
         * 1.二维数组包含10个一维数组
         * 2.为了防止在放入数值的时候，数据溢出，则每个一维数组（桶），大小定义为arr.length
         * 3.名明确,基础排序是使用空间换时间的经典算法
         */
        int[][] bucket = new int[10][arr.length];

        /**
         * 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数
         * 可以这么理解:
         * 比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数
         */
        int[] bucketElementCounts = new int[10];

        //第一轮（针对每个元素的个位进行排序处理）
        for(int j = 0;j < arr.length;j ++){
            //取出每个元素的个位的值
            int digitOfElement = arr[j] % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement] ++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        int index = 0;
        //遍历每一桶，并将桶中的数据，放入到原数组
        for(int k = 0;k < bucketElementCounts.length;k ++){
            //如果桶中，有数据，我们才放入原数组
            if(bucketElementCounts[k] != 0){
                //循环该桶即第k个桶（即第k个一维数组），放入
                for(int l = 0;l < bucketElementCounts[k];l ++){
                    //取出元素放入到arr
                    arr[index ++] = bucket[k][l];
                }
            }
            bucketElementCounts[k] = 0;
        }
        System.out.println("第一轮排序结果："+Arrays.toString(arr));
        //======================================
        //第二轮(针对十位进行排序)
        for(int j = 0;j < arr.length;j ++){
            //取出每个元素的十位的值
            int digitOfElement = arr[j] / 10 % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement] ++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        index = 0;
        //遍历每一桶，并将桶中的数据，放入到原数组
        for(int k = 0;k < bucketElementCounts.length;k ++){
            //如果桶中，有数据，我们才放入原数组
            if(bucketElementCounts[k] != 0){
                //循环该桶即第k个桶（即第k个一维数组），放入
                for(int l = 0;l < bucketElementCounts[k];l ++){
                    //取出元素放入到arr
                    arr[index ++] = bucket[k][l];
                }
            }
            bucketElementCounts[k] = 0;
        }
        System.out.println("第二轮排序结果："+Arrays.toString(arr));
        //==========================================
        //第三轮(针对百位进行排序)
        for(int j = 0;j < arr.length;j ++){
            //取出每个元素的百位的值
            int digitOfElement = arr[j] / 100 % 10;
            //放入到对应的桶中
            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
            bucketElementCounts[digitOfElement] ++;
        }
        //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
        index = 0;
        //遍历每一桶，并将桶中的数据，放入到原数组
        for(int k = 0;k < bucketElementCounts.length;k ++){
            //如果桶中，有数据，我们才放入原数组
            if(bucketElementCounts[k] != 0){
                //循环该桶即第k个桶（即第k个一维数组），放入
                for(int l = 0;l < bucketElementCounts[k];l ++){
                    //取出元素放入到arr
                    arr[index ++] = bucket[k][l];
                }
            }
        }
        System.out.println("第三轮排序结果："+Arrays.toString(arr));
    }
}
```

规律：每轮求数值的位数值一直在改变其它不变

基数排序实现：

```java
@SuppressWarnings("all")
public class JichuSort {
    public static void main(String[] args) {
        int[] arr = {53, 3, 542, 748, 14, 214};
        radixSort(arr);
    }

    //基数排序方法
    public static void radixSort(int[] arr) {
        //根据前面的推到过程，我们可以得到最终的基数排序代码
        //1.得到数组中最大的数的位数
        int max = arr[0];//假设第一个元素就是最大为数
        for (int i = 1; i < arr.length; i++) {
            if (arr[i] > max) {
                max = arr[i];
            }
        }
        //得到最大数是几位数
        int maxLength = (max + "").length();

        /**
         * 第一轮（针对每个元素的个位进行排序处理）
         * 定义一个二维数组，表示10个桶，每个桶就是一个一维数组
         * 说明：
         * 1.二维数组包含10个一维数组
         * 2.为了防止在放入数值的时候，数据溢出，则每个一维数组（桶），大小定义为arr.length
         * 3.名明确,基础排序是使用空间换时间的经典算法
         */
        int[][] bucket = new int[10][arr.length];

        /**
         * 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数
         * 可以这么理解:
         * 比如：bucketElementCounts[0],记录的就是bucket[0]桶的放入数据个数
         */
        int[] bucketElementCounts = new int[10];

        for (int i = 0, n = 1; i < maxLength; i++, n *= 10) {

            //第一轮（针对每个元素的个位进行排序处理）
            for (int j = 0; j < arr.length; j++) {
                //取出每个元素的个位的值
                int digitOfElement = arr[j] / n % 10;
                //放入到对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];
                bucketElementCounts[digitOfElement]++;
            }
            //按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）
            int index = 0;
            //遍历每一桶，并将桶中的数据，放入到原数组
            for (int k = 0; k < bucketElementCounts.length; k++) {
                //如果桶中，有数据，我们才放入原数组
                if (bucketElementCounts[k] != 0) {
                    //循环该桶即第k个桶（即第k个一维数组），放入
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //取出元素放入到arr
                        arr[index++] = bucket[k][l];
                    }
                }
                bucketElementCounts[k] = 0;
            }
            System.out.println("第"+i+"轮排序结果：" + Arrays.toString(arr));
        }
    }
}
```

### 常用排序算法总结和对比

常用排序算法对比

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902636.png)

**相关术语解释**：

1. 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
2. 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
3. 内排序：所有排序操作都在内存中完成；
4. 外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
5. 时间复杂度： 一个算法执行所耗费的时间。
6. 空间复杂度：运行完一个程序所需内存的大小。
7. ==n==: 数据规模
8. ==k==: “桶”的个数
9. ==In-place==: 不占用额外内存
10. ==Out-place==: 占用额外内存 

## 查找算法

**查找算法介绍** 

在java中，我们常用的查找有四种:

1. 顺序(线性)查找
2. 二分查找/折半查找
3. 插值查找
4. 斐波那契查找

### 线性查找算法

<font style="color:red">要求数组是一个有序的数组</font>.

有一个数列： {1,8, 10, 89, 1000, 1234} ，判断数列中是否包含此名称【顺序查找】  要求: 如果找到了，就提示找到，并给出下标值。  

思路：如果查找到全部符合条件的值。[思路分析.]

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902359.png)

```java
public static void main(String[] args)
    {
        int arr[] = {1, 2, 3, 4, 5, 6};
        int i = lineSearch(arr, 5);
        System.out.println(i);
    }
    private static int lineSearch(int arr[], int value)
    {
        for(int i = 0; i < arr.length; i++)
        {
            if(arr[i] == value)
            {
                return i;
            }
        }
        return -1;
    }
```

打印结果：

```
4
```



### 二分查找算法

**二分查找**：

<font style="color:red">要求数组是一个有序的数组</font>.

请对一个有序数组进行二分查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。  

课后思考题： {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.

代码实现：

```java
public class Binary_search {
    //二分查找
    public static void main(String[]args){
        int[] ar = {1,3,5,7,8,9};
        int x = run(ar,8);
        System.out.println(x);
    }
    public static int run(int[] nums,int trans){
        int mid = 0;
        int first = 0;
        int last = nums.length - 1;
        //判断 目标值是否小于索引0的值,目标值是否大于索引长度的值,长度
        if(trans < nums[first] || trans > nums[last] || first > last)
            return -1;
        //判断循环
        while(first <= last){
            //将长度除2的值赋值给mid,起始位置,访问数组中间的数据
            mid = (first + last) / 2;
            //判断数字是否小了
            if(nums[mid] > trans)
                //如果小了则让last - 1然后再次除2判断数字的大小
                last = mid - 1;
            //else只执行一个结果
            else
                //判断数字是否大了
            if(nums[mid] < trans)
                //如果数字大了则first + 1然后再次除2判断数字的大了,每次都是一半一半的进行试探的判断
                first = mid + 1;
            //else只执行一个结果
            else
                //如果两个判断不满足则执行返回值当前的索引位置就是目标值
            return mid;
        }
        //如果全程没有找到则返回 -1
        return -1;
    }
}
```

递归实现：

```java
@SuppressWarnings("all")
public class Chazhao01 {
    public static void main(String[] args) {
        int[] arr = {1,8, 10, 89, 1000, 1000,1234};
        int i = binarySearch(arr, 0, arr.length - 1, 89);
        System.out.println(i);
        List<Integer> i1 = binarySearch1(arr, 0, arr.length - 1, 1000);
        System.out.println("多个值的下标："+i1);
    }

    /**
     * @param arr 数组
     * @param left 左边的索引
     * @param right 右边的索引
     * @param value 要查找的值
     * @return 如果找到就返回下标，否则返回-1
     */
    public static int binarySearch(int[] arr,int left,int right,int value){
        if(left > right){
            return - 1;
        }

        int mid = (left + right) / 2;
        int midValue = arr[mid];
        if(value > midValue){//向右递归
            return binarySearch(arr,mid + 1,right,value);
        }else if(value < midValue){//向左递归
            return binarySearch(arr,left,mid - 1,value);
        }else {
            return mid;
        }
    }

    public static List<Integer> binarySearch1(int[] arr,int left,int right,int value){
        if(left > right){
            return new ArrayList<>();
        }

        int mid = (left + right) / 2;
        int midValue = arr[mid];
        if(value > midValue){//向右递归
            return binarySearch1(arr,mid + 1,right,value);
        }else if(value < midValue){//向左递归
            return binarySearch1(arr,left,mid - 1,value);
        }else{
            /**
             * 思路分析
             * 1.在找到mid索引值，不要马上返回
             * 2.向mid索引值的左边扫描，将所有满足value的元素下标加入集合中
             * 3.向mid索引值的右边扫描，将所有满足value的元素下标加入集合中
             * 4.将集合返回
             */
            List<Integer> list = new ArrayList<>();
            //向mid索引值的左边扫描，将所有满足value的元素的下标加入集合中
            int temp = mid - 1;
            while(true){
                if(temp < 0 || arr[temp] != value){//结束
                    break;
                }
                //否则，将temp放入到集合中
                list.add(temp);
                //temp左移
                temp -= 1;
            }
            list.add(mid);
            temp = mid + 1;
            while(true){
                if(temp > arr.length - 1 || arr[temp] != value){
                    break;
                }
                list.add(temp);
                temp += 1;
            }
            return list;
        }
    }
}
```

### 插值查找算法

**插值查找原理介绍**:

1. 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
2. 将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.  key 就是前面我们讲的 findVal
![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902056.png)
3. int mid = low + (high - low) `*` (key - arr[low]) / (arr[high] -arr[low]) ;/*插值索引*/  
对应前面的代码公式：  
int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])  


4. 举例说明插值查找算法 1-100 的数组

代码实现：

```java
@SuppressWarnings("all")
public class InsertValueSearch {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for(int i = 1;i <= 100;i ++){
            arr[(i - 1)] += i;
        }
        System.out.println(insertValuesearch(arr,0,arr.length - 1,100));
    }

    /**
     * @param arr 数组
     * @param left 左边索引
     * @param right 右边索引
     * @param value 查找值
     * @return 如果找到，返回对应下标，没有返回 -1
     */
    public static int insertValuesearch(int[] arr,int left,int right,int value){
        /**
         * 注意：value < arr[0] 和 value > arr[arr.length - 1] 必须需要
         * 否则我们得到的mid可能越界
         * arr.length - 1 < right 判断传入的right值是否大于了传入数组的长度
         */
        if(left > right || value < arr[0] || value > arr[arr.length - 1] || arr.length - 1 < right){
            return -1;
        }

        //求mid的值 称为自适应写法
        int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]);

        int midVal = arr[mid];

        if (value > midVal) {
            //向右边递归
            return insertValuesearch(arr,mid + 1,right,value);
        }else if(value < midVal) {
            //向左边递归
            return insertValuesearch(arr,left,mid - 1,value);
        }else{
            return mid;
        }
    }
}
```

<font style="color:red">插入查找注意事项</font>：

1.  对于数据量较大，**关键字分布比较均匀**的查找表来说，采用**插值查找**,**速度较快**.
2.  关键字分布不均匀的情况下，该方法不一定比折半查找要好

### 斐波那契(黄金分割法)查找算法

**斐波那契(黄金分割法)查找基本介绍**:

1. 黄金分割点是指把一条[线段](https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5/8679802)分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是[0.618](https://baike.baidu.com/item/0.618)。由于按此比例设计的造型十分美丽，因此称为[黄金分割](https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896)，也称为[中外比](https://baike.baidu.com/item/%E4%B8%AD%E5%A4%96%E6%AF%94/7590939)。这是一个神奇的数字，会带来意向不大的效果。  

2. 斐波那契数列  {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902110.png)

斐波那契(黄金分割法)查找算法

**斐波那契(黄金分割法)原理**:

斐波那契查找原理与前两种相似，仅仅  改变了中间结点（mid）的位置，mid不  再是中间或插值得到，而是位于黄金分  割点附近，即mid=low+F(k-1)-1  （F代表斐波那契数列），如下图所示
对F(k-1)-1的理解：

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161902101.png)

1. 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1
2. 类似的，每一子段也可以用相同的方式分割
3. 但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。

**斐波那契查找应用案例**：

请对一个有序数组进行斐波那契查找 {1,8, 10, 89, 1000, 1234} ，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示"没有这个数"。

**代码实现**：

```java
@SuppressWarnings("all")
public class FibonnacciSearch {
    public static int maxSize = 20;
    public static void main(String[] args) {
        int[] arr = {1,8, 10, 89, 1000, 1234};
        int i = fibSearch(arr, 89);
        System.out.println("index : "+i);
        System.out.println(Arrays.toString(fib()));
    }
    /**
     * 因为后面我们mid = low + f[k - 1] - 1;需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列
     * 非递归方法得到一个斐波那契数列
     * @return
     */
    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for(int i = 2;i < maxSize;i ++){
            f[i] = f[i - 1] + f[i - 2];
        }
        return f;
    }

    /**
     * 编写斐波那契数列查找算法
     * 使用递归方式编写算法
     * @param a 数组
     * @param key 我们需要查找的关键值
     * @return 返回对应的下标，如果没有返回-1
     */
    public static int fibSearch(int[] a,int key){
        int low = 0;
        int high = a.length - 1;
        int k = 0;//表示斐波那契数列分割数值的下标
        int mid = 0;//存放mid的值
        int[] f = fib();
        //f[k] = 1,1,2,3,5,8 (8 - 1 = 7) ==> false k == 5
        while(high > f[k] - 1){
            k ++;
        }
        /**
         * 因为f[k]值可能大于a的长度，因此我们需要使用Arrays类，构造一个新数组，并指向a[]
         * 不足的部分会使用0填充
         * [1, 8, 10, 89, 1000, 1234, 0, 0]
         */
        int[] temp = Arrays.copyOf(a,f[k]);
        /**
         * 实际上需求使用a数组最后的数填充temp
         * 举例：
         * temp = {1,8, 10, 89, 1000, 1234} => {1,8, 10, 89, 1000, 1234,1234,1234}
         */
        for(int i = high + 1;i < temp.length;i ++){
            temp[i] = a[high];
        }
        //使用while来循环处理，找到我们的数key
        while(low <= high){
            mid = low + f[k - 1] - 1;
            if(key < temp	[mid]){
                high = mid - 1;
                /**
                 * 为什么是 k--
                 * 说明：
                 * 1.全部元素 = 前面的元素 + 后面元素
                 * 2.f[k] = f[k - 1] + f[k - 2];
                 * 因为前面有f[k - 1]个元素，所以可以继续拆分f[k - 1] = f[k - 2] + f[k - 3]
                 * 即在f[k - 1]的前面继续查找k --
                 * 即下次循环mid = f[k - 1 - 1] - 1
                 */
                k--;
            }else if(key > temp[mid]){//我们应该继续向数组的后面查找(右边)
                low = mid + 1;
                /**
                 * 为什么是 k -= 2;
                 * 说明：
                 * 1.全部元素 = 前面元素+后面元素
                 * 2.f[k] = f[k - 1]  + f[k - 2]
                 * 3.因为后面我们有f[k - 2]所以可以继续拆分f[k - 1] = f[k - 3] + f[k - 4]
                 * 4.即在f[k - 2]的前面进行查找k -= 2
                 * 5.即下次循环mid = f[k - 1 - 2] - 1
                 */
                k -= 2;
            }else{
                //需要确定，返回的是哪个下标
                if(mid <= high){
                    return mid;
                }else{
                    return high;
                }
            }
        }
        return -1;
    }
}
```

## 哈希表

**看一个实际需求，google公司的一个上机题**:

有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.

要求: 不使用数据库,尽量节省内存,速度越快越好  =>  ==哈希表==(散列)

**哈希表的基本介绍** 

[散列表](https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8)（Hash table，也叫**哈希表**），是根据关键码值(Key value)而直接进行访问的[数据结构](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450)。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做[散列函数](https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0)，存放记录的[数组](https://baike.baidu.com/item/%E6%95%B0%E7%BB%84)叫做[散列](https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8)[表](https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8)。

15  111 % 15

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903974.png)

**哈希表(散列)-应用实例** 

**google公司的一个上机题**:

有一个公司,当有新的员工来报道时,要求将该员工的信息加入 (id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的 所有信息.

要求:

不使用数据库,速度越快越好 => ==哈希表== (散列)

添加时，保证按照id从低到高插入  [课后思考：如果id不是从 低到高插入，但要求各条链表仍是从低到高，怎么解决?]

1. 使用链表来实现哈希表, 该链表不带表头  [即: 链表的第一个结点就存放雇员信息]
2. 思路分析并画出示意图
3. 代码实现[增删改查(显示所有员工，按id查询)]

示意图：

![](https://raw.githubusercontent.com/PigPigLetsGo/imeages/master/202309161903704.png)

代码实现：

```java
@SuppressWarnings("all")
public class HashTableDemo {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        HashTable hashTable = new HashTable(7);
        char ch = ' ';
        boolean flag = true;
        while(flag){
            System.out.println("l(list) 查看所有雇员信息");
            System.out.println("a(add) 添加雇员信息到链表");
            System.out.println("s(select) 根据id查找指定雇员");
            System.out.println("d(delet) 根据id删除指定雇员信息,并返回信息");
            System.out.println("D(delet) 根据id删除指定雇员信息");
            System.out.println("e(exit) 退出");
            System.out.println("=======================");
            ch = sc.next().charAt(0);
            switch(ch){
                case 's':
                    System.out.println("请输入需要查找的雇员id");
                    int id1 = sc.nextInt();
                    hashTable.findEmpById(id1);
                    break;
                case 'l':
                    hashTable.list();
                    break;
                case 'a':
                    System.out.println("请输入id");
                    int id = sc.nextInt();
                    System.out.println("请输入名称");
                    String name = sc.next();
                    Emp emp = new Emp(id,name);
                    hashTable.add(emp);
                    break;
                case 'd':
                    try{
                        System.out.println("请输入要删除的雇员id");
                        int id2 = sc.nextInt();
                        Emp emp1 = hashTable.delEmp(id2);
                        System.out.printf(">>>\tData:\t%s\n",emp1);
                    }catch(Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'D':
                    try {
                        System.out.println("请输入要删除的雇员id");
                        int vlaue = sc.nextInt();
                        hashTable.delEmp01(vlaue);
                    } catch (Exception e) {
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    sc.close();
                    flag = false;
                    break;
                default:
                    System.out.println("选择存在项");
                    break;
            }
        }
    }
}
@SuppressWarnings("all")
//创建HashTable管理多条链表
class HashTable{
    private EmpLinkedList[] empLinkedListArray;
    //表示共有多少条链表(链表的大小)
    private int size;
    //构造器，初始化链表
    public HashTable(int size) {
        //初始化size值
        this.size = size;
        //初始化数组大小
        empLinkedListArray = new EmpLinkedList[size];
        //TODO 注意: 每一个链表都需要初始化否则报错空指针异常
        for(int i = 0;i < size;i ++){
            empLinkedListArray[i] = new EmpLinkedList();
        }
    }

    //添加雇员
    public void add(Emp emp){
        //根据员工的id，得到该员工应当添加到哪条链表
        int num = hashFun(emp.id);
        //将emp添加到对应的链表中
        empLinkedListArray[num - 1].add(emp);
    }

    //遍历所有的链表(遍历HashTable)
    public void list(){
        for(int i = 0;i < size;i ++){
            empLinkedListArray[i].list(i);
        }
    }

    //编写散列函数，使用一个简单取模法
    public int hashFun(int id){
        return id % size;
    }

    //根据id查找雇员
    public void findEmpById(int id){
        int num = hashFun(id);
        Emp emp = empLinkedListArray[num - 1].findById(id);
        if(emp != null){
            System.out.printf("在第%d个链表中查找到 的雇员信息如下：\n>>> id: %d\n>>> name: %s",num,emp.id,emp.name+"\n");
        }else{
            System.out.println("抱歉>"+num+"<链表中没有找到任何信息");
        }
    }

    public Emp delEmp(int id){
        int num = hashFun(id);
        Emp del = empLinkedListArray[num - 1].del(id);
        return del;
    }


    public void delEmp01(int id){
        int num = hashFun(id);
        empLinkedListArray[num - 1].del01(id);
    }
}
@SuppressWarnings("all")
//表示一个雇员
class Emp{
    public int id;
    public String name;
    public Emp next;

    public Emp(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Emp{" +
                "id=" + id +
                ", name='" + name + '\'';
    }
}
@SuppressWarnings("all")
//表示链表
class EmpLinkedList{
    //头指针，执行第一个Emp，因此我们这个链表的head是直接指向第一个Emp
    private Emp head;

    /**
     * 添加雇员到链表
     * 说明：
     * 1.假设，当添加雇员时，id是自增长，即id的分配总是从小到大
     * 因此我们将该雇员直接加入到本链表的最后即可
     * @param emp
     */
    public void add(Emp emp){
        //如果是添加第一个雇员
        if(head == null){
            head = emp;
            return;
        }
        //如果不是第一个雇员，则使用一个辅助指针，帮助定位到最后
        Emp curEmp = head;
        while(true){
            //说明到链表最后
            if(curEmp.next == null)
                break;
            //指针后移
            curEmp = curEmp.next;
        }
        //退出时直接将tmp加入到链表即可
        curEmp.next = emp;
    }

    /**
     * 遍历链表的雇员信a
     */
    public void list(int no){
        if(head == null){
            System.out.println("第>"+(no + 1)+"<个链表为空");
            return;
        }
        System.out.println("*-==第>"+(no + 1)+"<个链表中的雇员的信息为==-*");
        Emp curEmp = head;
        while(true){
            System.out.printf(">>> id: %d \n>>> name: %s",curEmp.id,curEmp.name+"\n");
            //判断是否遍历到链表的最后
            if(curEmp.next == null)
                break;
            //指针后移
            curEmp = curEmp.next;
        }
    }

    //根据id查找雇员信息
    public Emp findById(int id){
        if(head == null){
            return null;
        }
        Emp curEmp = head;
        boolean flag = false;
        while(true){
            if(curEmp.id == id){
                flag = true;
                break;
            }
            if(curEmp.next == null){
                break;
            }
            curEmp = curEmp.next;
        }
        if(flag){
            return curEmp;
        }else{
            return null;
        }
    }

    //根据id删除雇员,并返回删除的雇员信息
    public Emp del(int id){
        if(head == null){
            throw new RuntimeException(">>>"+id+"<链表为空删除无效");
        }
        //赋值指针
        Emp curEmp = head;
        //记录上一个位置指针
        Emp pre = head;
        while(true){
            if(curEmp.id == id){
                break;
            }
            if(curEmp == null){
                curEmp = null;
                break;
            }
            //将当前节点赋值给pre
            pre = curEmp;
            //curEmp节点向后移动
            curEmp = curEmp.next;
        }
        //判断当前节点是否为null
        if(curEmp == null){
            return null;
        }
        //判断头节点是否和当前节点相同
        if(head == curEmp){
            //将curEmp.next元素赋值给头节点
            head = curEmp.next;
            return curEmp;
        }
        //将赋值的元素再赋值给pre的next
        pre.next = curEmp.next;
        return curEmp;
    }

    //根据id删除雇员
    public void del01(int id){
        if(head == null){
            throw new RuntimeException(">>>"+id+"<链表为空删除无效");
        }
        Emp curEmp = head;
        boolean flag = false;
        while(true){
            if(curEmp.id == id){
                flag = true;
                break;
            }
            if(curEmp == null){
                break;
            }
            curEmp = curEmp.next;
        }
        if(flag){
            System.out.println("该"+id+"雇员删除成功");
            //判断下一个next节点是否为null
            if(curEmp.next == null){
                //如果下一个next就是null那么就说明了这是第一个元素直接将头元素赋值为null即可
                head = null;
            }else{
                //否则将下一个元素赋值为null
                curEmp.next = null;
            }
        }else{
            System.out.println("您输入的雇员可能本来就不存在");
        }
    }
}
```